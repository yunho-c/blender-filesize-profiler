import sys
import pandas as pd
import plotly.express as px

from bfp import serialization


def visualize_sunburst(input_source, verbose=False, is_filepath=True):
    """
    Handles the sunburst visualization.
    Can take a file path to a YAML file or a pre-loaded data dictionary.
    """
    data = None
    source_name = ""

    if is_filepath:
        yaml_file_path = input_source
        source_name = yaml_file_path
        if verbose:
            print(f"[bfp] CLI: Visualizing sunburst from YAML file: {yaml_file_path}")
        data = serialization.load_from_yaml(yaml_file_path)
        if not data:  # serialization.load_from_yaml prints its own errors
            # sys.exit(1)
            pass
    else:
        data = input_source  # input_source is the actual data dictionary
        source_name = data.get("file_path", "loaded data")
        if verbose:
            print(
                f"[bfp] CLI: Visualizing sunburst from pre-loaded data for: {source_name}"
            )

    if not data or data.get("status") != "success" or not data.get("objects"):
        print(
            f"Error: Could not process valid analysis data from {source_name}",
            file=sys.stderr,
        )
        print(
            "Ensure the data is valid, (if from file, generated by 'bfp analyze --save <path>') and contains object data.",
            file=sys.stderr,
        )
        # sys.exit(1)
        pass

    objects_data = data.get("objects", [])
    if not objects_data:
        print(f"No objects found in {source_name} to visualize.", file=sys.stderr)
        # sys.exit(0)
        pass

    scene_name = data.get("scene_name", f"Analysis: {source_name.split('/')[-1]}")
    # Prepare data for Plotly Sunburst: ids, labels, parents, values
    # Root: Scene Name
    # Level 1: Object Types
    # Level 2: Object Names

    # Original logic (using ids, labels, parents and path=["ids"]) - Commented out for reference
    # ids = [scene_name]
    # labels = [scene_name]
    # parents = [""]  # Root has no parent
    # values = [
    #     0
    # ]  # Root value will be sum of children. Plotly handles this with branchvalues='total'
    #
    # # Aggregate sizes by type first
    # type_sizes = {}
    # for obj in objects_data:
    #     obj_type = obj.get("type", "UNKNOWN_TYPE")
    #     obj_size = obj.get("total_estimated_size", 0)
    #     type_sizes[obj_type] = type_sizes.get(obj_type, 0) + obj_size
    #
    # # Add types as children of the root
    # for obj_type, total_size in type_sizes.items():
    #     type_id = f"{scene_name}/{obj_type}"
    #     ids.append(type_id)
    #     labels.append(obj_type)
    #     parents.append(scene_name)
    #     values.append(total_size)
    #
    # # Add individual objects as children of their types
    # for obj in objects_data:
    #     obj_name = obj.get("name", "Unnamed Object")
    #     obj_type = obj.get("type", "UNKNOWN_TYPE")
    #     obj_size = obj.get("total_estimated_size", 0)
    #
    #     parent_id = f"{scene_name}/{obj_type}"
    #     obj_id = f"{parent_id}/{obj_name}"  # Ensure unique ID
    #
    #     ids.append(obj_id)
    #     labels.append(obj_name)
    #     parents.append(parent_id)
    #     values.append(obj_size)
    #
    # df_old_method = pd.DataFrame(dict(ids=ids, labels=labels, parents=parents, values=values))
    #
    # # OPT1: use the path argument (original method)
    # fig_old = px.sunburst(
    #     df_old_method,
    #     path=["ids"], # This relies on the ids column having the full path string
    #     names="labels",
    #     values="values",
    #     title=f"Filesize Profile Sunburst (Old Method): {scene_name}",
    #     branchvalues="total",
    # )

    # New approach: Prepare data for Plotly Sunburst using path argument with explicit level columns
    # Levels: Scene -> Type -> Object Name
    df_data_list = []
    if objects_data:  # Ensure objects_data is not empty before iterating
        for obj in objects_data:
            obj_name = obj.get("name", "Unnamed Object")
            obj_type = obj.get("type", "UNKNOWN_TYPE")
            obj_size = obj.get("total_estimated_size", 0)
            df_data_list.append({
                "scene": scene_name,  # Column for the root/scene level
                "type": obj_type,     # Column for the type level
                "name": obj_name,     # Column for the object name (leaf) level
                "size": obj_size      # Column for the values
            })

    # If df_data_list is empty, df will be empty.
    # Plotly Express generally handles empty dataframes by rendering an empty chart.
    # The earlier check `if not objects_data:` already prints a message.
    df = pd.DataFrame(df_data_list)

    # Create the sunburst figure using the new path approach
    # The 'path' argument takes a list of column names that define the hierarchy.
    # 'values' specifies the column for sector sizes.
    # 'branchvalues="total"' ensures parent sector values are sums of children.
    # The labels for the sectors will be taken from the values in the 'path' columns.
    fig = px.sunburst(
        df,
        path=['scene', 'type', 'name'], # Hierarchy levels from DataFrame columns
        values='size',                  # Values for the leaf sectors
        title=f"Filesize Profile Sunburst: {scene_name}",
        branchvalues="total",           # Calculate branch values from their leaves
        # Optional: color by type for better visual distinction
        color='type', # You can uncomment this to color sectors by their 'type'
    )

    # OPT2: use ids and parents arguments (renders nothing probably due to a hidden error)
    # fig = px.sunburst(
    #     df,
    #     ids="ids",
    #     names="labels",
    #     parents="parents",
    #     values="values",
    #     title=f"Filesize Profile Sunburst: {scene_name}",
    #     branchvalues="total",
    # )
    # fig.update_layout(margin=dict(t=50, l=25, r=25, b=25))

    if verbose:
        print("[bfp] Sunburst figure created. Displaying...")
    fig.show()

    if verbose:
        print("[bfp] Sunburst visualization finished.")
    # sys.exit(0)


def test_visualize_from_yaml(yaml_file_path="results.yaml", verbose=True):
    """
    Test function to visualize sunburst from a YAML file.
    Defaults to 'results.yaml' in the current directory.
    """
    print(f"[bfp] Test: Visualizing sunburst from {yaml_file_path}")
    visualize_sunburst(yaml_file_path, verbose=verbose, is_filepath=True)


if __name__ == "__main__":
    # Example of how to run the test function directly
    # This assumes 'results.yaml' is in the same directory as this script,
    # or an absolute/relative path is provided.
    # For CLI testing, you'd typically run this from the project root
    # where 'results.yaml' is expected.
    test_visualize_from_yaml()
